Basariat POS - Software Requirements Specification (SRS - Final - EN)
1. Introduction
1.1 Purpose: This document specifies the functional and non-functional requirements for the "Basariat POS" system. "Basariat POS" is a desktop application, built using JavaFX, designed to serve as a comprehensive Point of Sale (POS) and financial management solution for optical centers. It is intended to be a configurable product that individual centers can set up with their specific business details.
1.2 Scope: The scope of this document covers all features, functionalities, and constraints of the "Basariat POS" system. This includes: initial system and center profile configuration; user management and security (role-based access with granular permissions); comprehensive shift management for operational control and cash reconciliation (start/end, opening/closing cash, pause/resume, interruption handling, detailed reporting); patient registration and optical diagnostic tracking (including WhatsApp notification consent); detailed inventory management for optical goods (products, stock, pricing, purchase orders, low stock alerts); sales order processing (including custom items and abandoned order management) linked to active shifts; payment processing (full/partial, cash/bank, linked to shifts); expense tracking (including automated logging of losses from abandoned goods and linkage of cash expenses to shifts); appointment scheduling and status management; generation of financial, inventory, and operational reports (such as cash-basis Profit & Loss and detailed Shift Reports); audit logging of critical system activities with viewing capabilities for administrators; an integrated User Manual/Help section; an "About Basariat POS" information section detailing application version and developer credits; and a manual WhatsApp "Click-to-Chat" feature for patient notifications using configurable templates.
1.3 Definitions, Acronyms, Abbreviations:
POS: Point of Sale
SRS: Software Requirements Specification
UI: User Interface
UX: User Experience
DB: Database
LAN: Local Area Network
i18n: Internationalization
l10n: Localization
Admin: Administrator User Role
Cashier: Cashier/Receptionist User Role
SDG: Sudanese Pound (example currency, configurable by the center via CenterProfile)
OD: Oculus Dexter (Right Eye)
OS: Oculus Sinister (Left Eye)
SPH: Sphere (lens power)
CYL: Cylinder (lens power for astigmatism)
AXIS: Axis of Cylinder
ADD: Near Addition power for reading
IPD: Interpupillary Distance
BC: Base Curve (for contact lenses)
DIA: Diameter (for contact lenses)
SKU: Stock Keeping Unit
COGS: Cost of Goods Sold
PK: Primary Key (in database context)
FK: Foreign Key (in database context)
RTL: Right-to-Left (text/layout direction)
LTR: Left-to-Right (text/layout direction)
Shift: A defined work period for a user (typically a Cashier), during which financial transactions are recorded under their responsibility and reconciled at the end.
FXML: An XML-based language used by JavaFX to define the user interface.
BSP: Business Solution Provider (for WhatsApp Business API, though not directly used by Click-to-Chat).
1.4 References:
User requirements gathered through interactive discussions and iterative feedback.
Image of a sample prescription slip (IMG_20250509_182117.jpg) for determining optical diagnostic data fields.
Image of a sample business card ("مركز منال عووضة للبصريات" - IMG_20250515_110759.jpg) used as inspiration for the UI visual theme.
Basariat POS - Full Database Script (PostgreSQL - Final) document (ID: db_script_basariat_pos_final_v3).
1.5 Overview: This Software Requirements Specification (SRS) document is structured to provide a complete and standalone understanding of the "Basariat POS" system. It begins with an overall description, including product perspective, key functions, user characteristics, general constraints, and assumptions. Subsequent sections detail the specific functional requirements (FRs) categorized by system module or major feature area, non-functional requirements (NFRs) addressing quality attributes such as performance, usability, and security, and finally, interface requirements outlining interactions with other systems or hardware.
2. Overall Description
2.1 Product Perspective: "Basariat POS" is a standalone Java desktop application, with its user interface developed using JavaFX. It is designed to operate in a client-server architecture within an optical center's Local Area Network (LAN). The server component is a PostgreSQL database, which will be hosted on a designated computer (which could be the main POS terminal or a separate local server) within the center. Each optical center deploying "Basariat POS" will have its own independent installation and database instance, configured with their unique business details. The system is not web-based and is intended for on-premises use. The official application name is "Basariat POS".
2.2 Product Functions: The primary functions of "Basariat POS" are to provide optical centers with a comprehensive, user-friendly, and reliable tool for managing their daily operations and finances. This includes:
System Initialization & Customization: Allowing the center owner/admin to configure the system with their specific business details (name, address, logo, currency, receipt messages, etc.) during an initial setup process and modify them later.
User and Access Control: Providing secure user login, distinct user roles (Admin, Cashier), and a flexible system of granular permissions to control access to features and data.
Shift Operations Management: Enabling cashiers to formally start and end their work shifts, declare opening cash floats, accurately record all financial transactions (sales, payments, cash expenses) tied to their active shift, pause and resume shifts, and reconcile cash at shift end with system-calculated expected amounts. This includes handling unexpected application interruptions and providing detailed shift reports.
Comprehensive Patient Management: Maintaining detailed electronic records for patients, including contact information, full optical diagnostic history, and management of consent for receiving WhatsApp notifications.
Detailed Inventory & Product Control: Managing a complete catalog of optical products (frames, various types of lenses, contact lenses, solutions, accessories) and services, tracking stock levels, managing purchase orders and stock receipts, updating cost prices, setting selling prices, and alerting for low stock conditions.
Efficient Sales Order Processing: Facilitating the creation and management of sales orders from quotation to completion, including handling of custom spectacle lens configurations, application of discounts, processing of different payment types (full/partial, cash/bank), and linking all sales activities to the active user shift.
Management of Problematic Orders: Providing a defined workflow for handling orders that are abandoned by patients, including options for restocking eligible items and systematically accounting for any financial losses on unrecoverable goods.
Accurate Expense Tracking: Allowing for the recording of all business operational expenses, with appropriate categorization for reporting, and specifically linking cash expenses paid from the till to the active user shift.
Appointment Scheduling & Tracking: Managing patient appointments, primarily for order delivery or follow-up consultations, including tracking of appointment statuses (e.g., 'Scheduled', 'Confirmed', 'No Show').
Insightful Reporting: Generating a suite of financial reports (such as a Profit & Loss statement calculated on an actual cash received basis), inventory reports (valuation, stock levels), sales analysis reports, and detailed operational reports (including comprehensive shift reports with cash reconciliation).
Facilitated Patient Communication: Aiding staff in sending manual WhatsApp notifications to consenting patients for important updates (e.g., appointment reminders, order ready alerts) using a "Click-to-Chat" mechanism with pre-fillable, configurable message templates.
System Auditability: Maintaining a comprehensive audit trail by logging critical system events and data modifications, including the responsible user and timestamp, with viewing capabilities for administrators.
User Support & Information: Providing an integrated User Manual/Help section for easy reference on system usage, and an "About Basariat POS" section containing application version information and developer contact details.
2.3 User Characteristics:
Administrator (Admin): Typically the optical center owner or a designated manager. This user has full access privileges to all system functionalities. Responsibilities include initial system setup and CenterProfile configuration, ongoing management of system settings (e.g., bank names, expense categories, product categories, WhatsApp templates), user account creation and permission management, viewing all types of reports (including sensitive financial data such as P&L statements and detailed audit logs), and the ability to perform all operational tasks available to Cashier users. This user is assumed to have a comprehensive understanding of the optical center's business operations and may have moderate technical proficiency to oversee system administration.
Cashier/Receptionist (Cashier): The primary day-to-day operators of the system. Responsibilities include managing patient intake and records (including WhatsApp consent), recording sales transactions and processing payments, managing their individual work shifts (starting with an opening float, pausing/resuming, ending with cash reconciliation), potentially updating inventory information related to sales, scheduling patient appointments, and generating operational reports relevant to their tasks (e.g., their own shift report). Their access to sensitive data (like other users' shift reports or full financial statements) and administrative functions will be strictly limited by the permissions configured by the Admin. The user interface for this role must be highly intuitive, efficient, and easy to learn to minimize errors and training time.
2.4 General Constraints:
Technology Stack: The system shall be developed using Java 21 (or a compatible Long-Term Support version) as the core programming language. The user interface shall be implemented using JavaFX. PostgreSQL (a recent stable version) shall be used as the relational database management system. jOOQ shall be utilized as the framework for database interaction from the Java application.
Platform: The application is designed as a desktop application, primarily targeting Windows operating systems (e.g., Windows 10, Windows 11). While Java allows for cross-platform compatibility, focused testing and support will be on Windows.
Language Support: The application User Interface (UI) and data handling capabilities must fully support both English and Arabic languages. Arabic will be the default language for the UI. The system must correctly handle Right-to-Left (RTL) text direction and layout for Arabic, and Left-to-Right (LTR) for English.
Network Environment: The system operates within an optical center's Local Area Network (LAN). Client application instances will connect to a central PostgreSQL database server on the same LAN. Core operations do not require internet connectivity, except for the "Click-to-Chat" WhatsApp feature which relies on the user's machine having internet access and WhatsApp Web/Desktop.
Usability: A high degree of usability, intuitiveness, and ease of learning is a critical requirement, especially for the Cashier role. The UI should be clean, uncluttered, and follow the defined visual theme.
Auditability: All critical data modifications (inserts, updates, deletes on key tables) and significant system events (e.g., shift start/end, login attempts if configured) must be logged in an audit trail, including the responsible user and timestamp.
Resellability & Configurability: The system must be designed so that it can be installed and configured by different optical centers with their unique business information (via CenterProfile and other settings) without requiring code modifications.
Data Integrity: The system must ensure data integrity through database constraints, transactional operations, and appropriate input validations.
2.5 Assumptions and Dependencies:
A stable and reliable Local Area Network (LAN) infrastructure is available and correctly configured at each optical center where the "Basariat POS" system is deployed.
A designated computer (server PC) capable of running PostgreSQL reliably is available at each center. The center is responsible for the maintenance and regular backup of this database server.
The Java Runtime Environment (JRE) version 21 (or the version used for development), including all necessary JavaFX modules, is correctly installed on all client machines that will run the "Basariat POS" application.
The specific optical diagnostic parameters to be recorded are based on the fields identified in the provided sample prescription slip image (IMG_20250509_182117.jpg) and subsequent clarifications.
The "Basariat POS" application, upon user login, will be responsible for setting a session-level variable in the PostgreSQL database (e.g., app.current_user_id via the set_app_user() procedure) to identify the current user. This is crucial for the audit logging triggers to correctly attribute actions.
Similarly, when a user starts or resumes a shift, the application will set another session-level variable (e.g., app.current_shift_id via the set_app_shift() procedure) to identify the currently active shift for linking transactions. These session variables are cleared upon logout or shift end.
For the WhatsApp "Click-to-Chat" feature to function, it is assumed that the staff member's computer has active internet access and a configured WhatsApp Web session or an installed WhatsApp Desktop client that is linked to their WhatsApp account. The "Basariat POS" system only generates the wa.me/ link; the actual sending of the message is a manual step performed by the user within WhatsApp.
The initial password for the default 'Admin' user (if one is created during setup) will be a known default, with a strong recommendation for the Admin to change it immediately upon first login to a strong, unique password.
3. Functional Requirements (FR)
FR0: System Setup & Configuration
FR0.1: Initial Setup Wizard: On the first execution of the "Basariat POS" application on a system where the CenterProfile table is empty (or a specific setup flag indicates a new installation), the system shall automatically launch an interactive, step-by-step initial setup wizard.
FR0.2: Center Profile Data Collection: The setup wizard shall guide an Admin user through a series of steps to input and save essential CenterProfile details. These details shall include at least: center_name (required), address_line1, address_line2 (optional), city, country, postal_code (optional), phone_primary (required), phone_secondary (optional), email_address (optional), website (optional), logo_image_path (optional, path to a local image file for receipts/reports), tax_identifier (optional), default currency_symbol (e.g., "SDG", required), default currency_code (e.g., "SDG", required), and an optional default receipt_footer_message.
FR0.3: Center Profile Management: Admin users shall be able to access a dedicated "Center Profile" or "Business Settings" interface within the application at any time after the initial setup to view and modify all stored CenterProfile details. Changes to these details must be audit logged.
FR0.4: Profile Usage: The system shall dynamically use the configured CenterProfile details (e.g., center name, logo image, address, contact information, currency symbol) on all relevant system-generated outputs, including printed receipts, invoices, reports, and potentially in UI headers or footers to personalize the application instance.
FR0.5: Bank Name Management: Admin users shall be able to Create, Read, Update, and Deactivate/Reactivate BankNames used for recording bank transaction payments and expenses. Each bank name entry must support names in both English and Arabic.
FR0.6: Expense Category Management: Admin users shall be able to Create, Read, Update, and Deactivate/Reactivate ExpenseCategories. Each category must support names in both English and Arabic. A default, non-deletable (but perhaps renameable) category named "Loss on Abandoned Orders" (or its equivalent in Arabic) must be available or created by the system if not present.
FR0.7: Product Category Management: Admin users shall be able to Create, Read, Update, and Delete ProductCategories. Each category must support names in both English and Arabic. Deleting a category should only be allowed if no Products are currently assigned to it.
FR0.8: Application Settings Management: The system may provide an interface for Admins to manage key-value pairs in the ApplicationSettings table for other configurable parameters (e.g., default WhatsApp message templates, UI behavior flags).
FR1: User Authentication & Authorization
FR1.1: The system shall require all users to authenticate by providing a unique, case-sensitive username and a case-sensitive password before gaining access to any functionality beyond the login screen.
FR1.2: User passwords shall be stored in the Users.password_hash field in the database only after being processed by a strong, one-way, salted hashing algorithm (e.g., bcrypt or Argon2). Plaintext passwords must never be stored or logged by the system at any point.
FR1.3: The system shall support at least two distinct, pre-defined user roles: 'Admin' and 'Cashier', stored in the Users.role field.
FR1.4: Admin users shall have the exclusive ability to grant or revoke specific, granular permissions to users assigned the 'Cashier' role through an administrative interface. Examples of permissions include: CAN_GIVE_DISCOUNT, VIEW_FINANCIAL_REPORTS, EDIT_INVENTORY_PRICES, PROCESS_ABANDONED_ORDERS, MANAGE_STOCK_ADJUSTMENTS, VIEW_ALL_SHIFT_REPORTS. These permissions will be defined as distinct permission_name entries in the UserPermissions table and linked to a user_id with an is_granted status.
FR1.5: Access to all system features, functionalities, data views, and data modification operations shall be strictly controlled and restricted based on the logged-in user's assigned role and their explicitly granted permissions. Unauthorized actions must be prevented.
FR1.6: Upon successful user login, the application must immediately call the set_app_user(user_id) database procedure to establish the current user's context for the active database session, enabling this information to be captured by database audit log triggers for attributing actions. This session variable must be cleared or invalidated upon user logout or session termination.
FR2: User Management (Admin only)
FR2.1: Admin users shall be able to Create, Read, Update (e.g., full name, username, role, active/inactive status), and effectively Delete (by deactivating) user accounts, primarily for the 'Cashier' role. A default 'Admin' account should be configurable during initial system setup or created with a secure default that must be changed on first login. Admins should not be able to delete their own account if it's the sole active admin account.
FR2.2: Admin users shall be able to assign and modify the set of granular permissions (as defined in FR1.4) for each individual 'Cashier' user account through an intuitive administrative interface.
FR2.3: Admin users shall have the capability to reset the password for any other user account. The system should enforce a secure password reset mechanism, such as generating a strong, temporary password that the target user is required to change upon their next successful login.
FR3: Shift Management
FR3.1: Start Shift:
FR3.1.1: Authorized users (typically 'Cashier' role, potentially 'Admin') shall be able to manually initiate a "Start Shift" action from a clearly designated UI control.
FR3.1.2: Before the shift starts, the system shall require the user to declare and input an opening_float (the initial amount of cash in the cash drawer for that specific shift). This amount must be a non-negative decimal value.
FR3.1.3: Upon successful validation of the opening float and user confirmation, the application shall call the StartShift database procedure, passing the current user_id and the declared opening_float. This procedure will create a new record in the Shifts table with status set to 'Active', start_time as the current timestamp, and store the started_by_user_id and opening_float. The procedure will return the newly generated shift_id.
FR3.1.4: Immediately after the StartShift procedure successfully returns the new shift_id, the application must call the set_app_shift(new_shift_id) database procedure to associate the current application session with this active shift. This app.current_shift_id session variable is crucial for linking subsequent transactions to this shift.
FR3.1.5: A user shall be prevented from starting a new shift if they already have an existing shift in an 'Active' or 'Paused' state. This rule is enforced by the idx_unique_active_paused_shift_per_user unique index in the database and should also be checked by the application logic before attempting to start a new shift.
FR3.2: Active Shift Operations:
FR3.2.1: All sales orders (SalesOrders), payments received (Payments), and cash-based expenses (Expenses where payment_method = 'Cash') created or processed by the logged-in user must be automatically associated with their currently active shift_id (retrieved via get_current_app_shift_id() which reads the app.current_shift_id session variable). This linkage is primarily enforced by the check_active_shift_for_transaction database trigger when these records are inserted.
FR3.2.2: The system (both application UI logic and the database trigger) shall strictly prevent the creation or processing of these financial transactions if the logged-in user does not have a currently 'Active' shift. Users attempting such actions without an active shift must be informed with a clear message.
FR3.3: Pause & Resume Shift:
FR3.3.1: A user who has an 'Active' shift shall have a clearly identifiable option in the UI to "Pause Shift."
FR3.3.2: Invoking "Pause Shift" shall trigger a call to the PauseShift database procedure, passing the current shift_id and user_id. This procedure updates the Shifts.status to 'Paused', records the event (user, timestamp) in the ShiftPauseLog table. Following a successful pause, the application must call set_app_shift(NULL) to clear the active shift context for the current session.
FR3.3.3: A user who previously started a shift that is currently 'Paused' or was 'Interrupted' shall have a clearly identifiable option to "Resume Shift."
FR3.3.4: Invoking "Resume Shift" shall trigger a call to the ResumeShift database procedure, passing the shift_id and user_id. This procedure updates the Shifts.status back to 'Active', updates the corresponding ShiftPauseLog entry with the resume timestamp (if resuming from 'Paused'), and the application must then call set_app_shift(resumed_shift_id) to re-establish the active shift context for the session.
FR3.4: End Shift:
FR3.4.1: A user who has an 'Active', 'Paused', or 'Interrupted' shift associated with them shall be able to initiate an "End Shift" action from the UI.
FR3.4.2: Before finalizing the end of the shift, the system shall prompt the user to physically count the cash in their drawer and enter this value as the closing_cash_counted. The user may also be allowed to enter optional notes for the shift (e.g., explaining any discrepancies or unusual events).
FR3.4.3: Upon confirmation, the application shall call the EndShift database procedure, passing the shift_id, current user_id, the entered closing_cash_counted, and any notes. This procedure is responsible for:
Calculating the expected_cash_in_drawer based on: opening_float + sum of all cash Payments.amount linked to the shift - sum of all cash Expenses.amount linked to the shift.
Calculating the cash_variance as (closing_cash_counted - expected_cash_in_drawer).
Updating the Shifts record with the end_time (current timestamp), status 'Ended', closing_cash_counted, calculated expected_cash_in_drawer, calculated cash_variance, and any provided notes.
If the shift was 'Paused' when ended, its last ShiftPauseLog entry should be updated to reflect the end.
FR3.4.4: After the EndShift procedure successfully completes, the application must call set_app_shift(NULL) to clear the active shift context for the current session.
FR3.4.5: The system shall then automatically generate and display (or offer to print) the Shift Report for the just-ended shift.
FR3.5: Interruption Handling:
FR3.5.1: If the "Basariat POS" application closes unexpectedly (e.g., power outage, system crash) or if a user logs out without formally ending an 'Active' or 'Paused' shift, upon the next login by that same user, the system must perform a check to detect if such an "Interrupted" shift exists (by querying the Shifts table for shifts associated with that user that are not in 'Ended' or 'Cancelled' state). The database might mark such shifts as 'Interrupted' via a startup check or this is handled by application logic.
FR3.5.2: If an interrupted shift is detected, the user shall be immediately prompted with clear options, such as "Resume Interrupted Shift" or "Forcibly End Interrupted Shift."
Resuming the shift will follow the logic of FR3.3.4.
Forcibly ending an interrupted shift may require special procedures, such as requiring an Admin override or specific instructions for cash counting (e.g., counting cash based on the last known state and heavily documenting the situation in shift notes). This action would ultimately use the EndShift procedure, possibly with a flag or note indicating it was an interrupted closure.
FR3.6: Shift Reporting:
FR3.6.1: The system shall provide a comprehensive and printable Shift Report for each 'Ended' shift.
FR3.6.2: The Shift Report Summary section (derived from data in ShiftReportSummaryView) must clearly display: Shift ID, Start Time and Date, End Time and Date, User who conducted the shift (Username & Full Name), final Shift Status ('Ended'), Opening Float amount, Total Cash Sales during the shift, Total Bank Transaction Sales during the shift, Total Cash Payments Received on Account during the shift, Total Bank Payments Received on Account during the shift, Total Cash Expenses Paid out from the till during the shift, Total Number of Sales Orders created/processed during the shift, Total Discounts Given during the shift, System-Calculated Expected Cash in Drawer, User-Entered Closing Cash Counted, and the final Cash Variance (Over/Short), clearly indicating if it's a surplus or shortage.
FR3.6.3: The Shift Report must also include a Detailed Transaction List section (derived from data in ShiftReportDetailedTransactionsView) itemizing all individual financial transactions (sales order items with amounts, payments received with method, cash expenses paid out) that were associated with that specific shift, including timestamps and relevant details like patient name or expense description.
FR3.6.4: Access to view and print shift reports shall be available to:
The user who conducted the shift (for their own past and current shift reports).
Admin users (for any shift report, current or historical).
FR3.6.5: The interface for accessing historical shift reports (especially for Admins) should allow filtering by date range and by user.
FR4: Patient Management
FR4.1: The system shall allow authorized users to perform Create, Read, Update, and Search operations on patient records. Each patient record shall include at least: a system-generated unique system_patient_id (e.g., prefixed with "PAT-"), full name, primary phone number (which should be validated for a plausible format and will be used for WhatsApp notifications), an optional secondary phone number, an optional address, and metadata (the user_id of the creator, creation timestamp, last update timestamp).
FR4.2: The system shall provide efficient search capabilities for patients by their system_patient_id, full name (partial matches allowed), or primary phone number. Search results should be displayed in a clear, sortable list.
FR4.3: From a patient's record, authorized users shall be able to view a complete history associated with that patient, including all past optical diagnostics, all sales orders (with their statuses and items), and all payments made.
FR4.4: Patient WhatsApp Notification Consent:
FR4.4.1: The Patients table shall include a boolean field whatsapp_opt_in, defaulting to FALSE, to explicitly store the patient's consent status for receiving WhatsApp notifications from the center.
FR4.4.2: During patient registration or when editing an existing patient's record, authorized users (e.g., Cashier) shall be able to update the patient's whatsapp_opt_in status via a clearly labeled checkbox or a similar UI element on the patient information form. This update must be based on explicit verbal or written consent obtained from the patient by the center's staff.
FR4.4.3: The system itself will not attempt to programmatically verify if a patient's phone number has an active WhatsApp account; this is determined externally when the "Click-to-Chat" link is activated by the staff member.
FR5: Optical Diagnostics Management
FR5.1: The system shall allow authorized users to record new optical diagnostic results, which must be linked to a specific patient record. Each diagnostic record shall capture: diagnostic_date (defaulting to current date but editable), a boolean flag is_contact_lens_rx to indicate if the prescription is specifically for contact lenses, contact_lens_details (a free-text field for CL brand, type, or specific instructions if is_contact_lens_rx is true), distance prescription parameters for both Right Eye (OD) and Left Eye (OS) including Sphere (od_sph_dist), Cylinder (od_cyl_dist), and AXIS (od_axis_dist), near addition power for OD and OS (od_add, os_add), binocular Interpupillary Distance (ipd), and a general remarks text field for any additional notes by the optometrist.
FR5.2: The system shall store and display a chronological history of all optical diagnostic records for each patient, ordered by diagnostic_date (most recent first), allowing easy review of prescription changes and diagnostic history over time.
FR6: Product & Inventory Management
FR6.1: Product Categories: Admin users shall be able to perform full Create, Read, Update, and Delete (CRUD) operations on ProductCategories. Each category must have a unique category_name_en (English name) and category_name_ar (Arabic name). Deleting a category should only be allowed if no Products are currently assigned to it.
FR6.2: Products (Master Definition): Admin users shall be able to perform full CRUD operations on master Products. Each product record shall be linked to a ProductCategory, have an optional unique product_code (for internal SKU or supplier reference), mandatory product_name_en and product_name_ar, optional description_en and description_ar, and flags is_service (TRUE if it's a service, FALSE if a physical good) and is_stock_item (TRUE if its quantity is tracked in inventory, FALSE for pure services or non-stock items).
FR6.3: Inventory Items (Specific Stockable Variants):
FR6.3.1: For Products where is_stock_item is TRUE, authorized users (Admin or Cashier with appropriate permissions) shall be able to manage specific InventoryItems. This includes Create, Read, Update, and Deactivate (soft delete via is_active flag) operations.
FR6.3.2: Each InventoryItem record shall store: a link to its master Product (product_id), an optional brand_name, specific identifying names (item_specific_name_en, item_specific_name_ar - e.g., "Ray-Ban Aviator RB3025 Gold 58mm"), attributes (a JSONB field to store key-value pairs for variations like color, frame size, lens power for stock lenses, diopter strength for ready-made reading glasses, volume for solutions, etc.), current quantity_on_hand (non-negative integer), selling_price (decimal, mandatory), cost_price (decimal, last purchase price), min_stock_level (integer, for reorder alerts), unit_of_measure (text, e.g., 'Unit', 'Box', 'Pair', 'Bottle'), and an is_active flag.
FR6.3.3: The selling_price for each InventoryItem shall be set and modifiable by users with the appropriate permission (e.g., EDIT_INVENTORY_PRICES).
FR6.3.4: The cost_price for each InventoryItem shall be automatically updated to the purchase_price_per_unit from the most recently received (i.e., quantity_received > 0) PurchaseOrderItem for that specific InventoryItem. This update is handled by the trg_update_inventory_on_po_receipt database trigger.
FR6.4: Stock Adjustments: Authorized users (possessing a specific MANAGE_STOCK_ADJUSTMENTS permission) shall be able to manually adjust the quantity_on_hand for any InventoryItem. A mandatory reason for each adjustment (e.g., "Damaged Goods", "Stock Count Correction", "Initial Stock Entry", "Promotional Use", "Expired Stock Write-off") must be selected from a predefined list or entered as text, and recorded along with the adjustment details. All manual stock adjustments must be logged in the AuditLog, including the user, timestamp, item, quantity change, and reason.
FR6.5: Low Stock Alert: The system shall provide a clear mechanism for users (especially Admin and inventory managers) to identify items that require reordering. This will be achieved through a dedicated report or a dashboard component that lists all active InventoryItems where the current quantity_on_hand is at or below the defined min_stock_level (utilizing the LowStockItemsView).
FR6.6: Purchase Orders:
FR6.6.1: Authorized users shall be able to create new PurchaseOrders (POs), specifying an order_date (defaulting to current date but editable) and a supplier_name (as free text).
FR6.6.2: Users shall add PurchaseOrderItems to a PO. Each line item must link to a specific InventoryItem and include the quantity_ordered and the purchase_price_per_unit for that item in that specific order. The PO's total_amount (sum of all item subtotals) shall be calculated and updated automatically by the trg_update_po_total database trigger whenever items are added, modified, or removed.
FR6.6.3: Authorized users shall be able to process the receipt of goods against a saved PO by updating the quantity_received field for each PurchaseOrderItem. Users can record partial receipts.
FR6.6.4: When PurchaseOrderItems.quantity_received is updated (and is greater than zero), the trg_update_inventory_on_po_receipt database trigger shall automatically:
Increment the InventoryItems.quantity_on_hand by the newly received quantity.
Update the InventoryItems.cost_price to the new purchase_price_per_unit from that PurchaseOrderItem.
FR6.6.5: The PurchaseOrders.status shall be managed by the user (e.g., 'Pending' upon creation, 'Received' when all items are fully or partially received as per business process, 'Cancelled' if the order is voided before receipt).
FR7: Service Management
FR7.1: Admin users shall define services (e.g., "Eye Examination Fee," "Frame Adjustment," "Lens Replacement Labor") as records in the Products table by setting the is_service flag to TRUE and is_stock_item to FALSE (for pure services not tracked in inventory).
FR7.2: Pricing for standard, fixed-price services shall be defined. This can be done by creating a corresponding (non-stock) InventoryItem linked to the service Product and setting its selling_price, or if the service has no variations, the price might be directly associated with the Product record (though the current schema favors pricing on InventoryItem).
FR7.3: For services that require a custom quote at the time of sale (e.g., complex "Frame Repair - Custom Work"), the unit_price and description shall be entered manually by an authorized user when adding the service as a SalesOrderItem to a SalesOrder.
FR8: Sales Order Processing (Linked to Active Shift)
FR8.1: Authorized users with an active shift (as per AppSessionManager and database session variable app.current_shift_id) shall be able to create new SalesOrders. Orders can be linked to a registered Patient (by selecting from search results) or processed as anonymous sales (where SalesOrders.patient_id is NULL).
FR8.2: Users shall add SalesOrderItems to a SalesOrder. Each item can be one of the following types:
Stock Inventory Item: Selected from the list of active InventoryItems (e.g., a specific frame, box of contact lenses, sunglasses, solution bottle). The unit_price will default to the InventoryItem.selling_price but may be editable with permission.
Standard Service: Selected from the list of service Products (or their InventoryItem representations if priced there). The unit_price will be pre-filled.
Custom Spectacle Lenses: This is a special type of SalesOrderItem. The process involves:
Selecting an associated Frame InventoryItem (if applicable, or it could be lenses only for patient's own frame).
Inputting or selecting the patient's prescription data (from their OpticalDiagnostics history or entered manually for this order).
Allowing the user to select lens material (e.g., Glass, Plastic, Polycarbonate, Blue Cut), shade (e.g., White, Photochromic, Tinted), and reflection type (e.g., Pure/Uncoated, Antireflective).
The system must enforce the business rule: "Blue Cut lenses are only Antireflective" (UI should auto-select AR if Blue Cut is chosen, or prevent de-selection of AR).
All these prescription details and chosen lens attributes will be stored in the SalesOrderItems.prescription_details JSONB field. The is_custom_lenses flag will be set to TRUE.
The unit_price for these custom lenses will be determined based on a pre-defined pricing logic or matrix (e.g., base lens price + add-ons for material, coatings, high index, etc.), or potentially by selecting pre-defined "lens packages" from InventoryItems that represent specific lens combinations.
Custom Quote Services: For services like complex repairs not having a standard price, the user shall enter a textual description and a unit_price manually for the SalesOrderItem.
FR8.3: The SalesOrders.subtotal_amount (which is the sum of all SalesOrderItems.item_subtotal for that order, before any discount is applied) shall be automatically calculated and updated by the trg_update_sales_order_subtotal database trigger. This trigger calls the RecalculateSalesOrderSubtotal procedure whenever SalesOrderItems are added, their quantities or prices are modified, or they are deleted from an order.
FR8.4: Authorized users (possessing the CAN_GIVE_DISCOUNT permission) shall be able to apply a fixed monetary discount_amount to the overall SalesOrder. The SalesOrders.total_amount (subtotal_amount - discount_amount) and SalesOrders.balance_due (total_amount - amount_paid) are database-generated columns that will update automatically.
FR8.5: The system shall allow authorized users to manage the SalesOrders.status through a defined lifecycle. Supported statuses include: 'Pending' (newly created, awaiting further action), 'Awaiting Lenses' (if custom lenses are being manufactured or ordered externally), 'Ready for Pickup' (all items are ready for the patient), 'Completed' (fully paid and goods/services delivered/rendered to the patient), 'Cancelled' (order voided before completion), and 'Abandoned' (order not collected after a period, see FR8.9). Status changes should be permission-controlled where appropriate (e.g., only Admin can cancel a partially paid order).
FR8.6: When a SalesOrder.status is changed to 'Completed' by an authorized user (and all payments are settled as per business rules), the application must explicitly call the ProcessOrderCompletionStockUpdate database procedure. This procedure will iterate through the SalesOrderItems of that order and deduct the quantity of sold stock InventoryItems from their respective InventoryItems.quantity_on_hand. This ensures stock levels are only affected upon confirmed completion of the sale.
FR8.7: The system shall be capable of generating printable receipts (for payments) and invoices/detailed sales orders. These documents must prominently display details from the CenterProfile (such as center name, address, contact numbers, and logo if configured). They must also include patient details (if the sale is not anonymous), the order/payment date and unique ID, an itemized list of all goods/services with quantities and prices, subtotal, any discount applied, tax information (if applicable - though tax calculation is not explicitly scoped yet), the total amount, amount paid, balance due, and any receipt_footer_message configured in CenterProfile.
FR8.8: Each SalesOrder must be irrevocably associated with the shift_id of the user's currently active shift at the time of its creation. This linkage is enforced by the check_active_shift_for_transaction database trigger, which uses get_current_app_shift_id().
FR8.9: Abandoned Order Processing: Authorized users (possessing a specific PROCESS_ABANDONED_ORDERS permission) shall be able to mark a sales order (that is not already 'Completed' or 'Cancelled') as 'Abandoned'. This action will be initiated via the application UI and will trigger a call to the ProcessAbandonedOrder database procedure.
FR8.10: The ProcessAbandonedOrder database procedure, when invoked, shall perform the following actions:
Update the SalesOrders.status to 'Abandoned'.
Accept an array of so_item_ids (passed from the application UI) representing items from the abandoned order that are deemed suitable for restocking.
For each item identified for restocking, the procedure will increment InventoryItems.quantity_on_hand by the item's quantity on the order and set the SalesOrderItems.is_restocked_on_abandonment flag to TRUE for that line item.
Calculate the total cost_price of all stock InventoryItems from the abandoned order that were not restocked (i.e., is_restocked_on_abandonment is FALSE). This represents the direct financial loss on unrecoverable goods.
If this calculated loss amount is greater than zero, the procedure will automatically create a new entry in the Expenses table. This expense record will be categorized under a specific ExpenseCategory (e.g., "Loss on Abandoned Orders"), its description will reference the SalesOrder.sales_order_id, the amount will be the calculated loss, the payment method will be 'Cash' (or a specific internal adjustment type), and it will be linked to the current active shift_id (obtained via get_current_app_shift_id()) and the user_id who initiated the abandonment.
FR9: Payment Processing (Linked to Active Shift)
FR9.1: Authorized users with an active shift shall record Payments made against SalesOrders by invoking the RecordPaymentAndUpdateSalesOrder database procedure through the application UI. The procedure call will include all necessary parameters: sales_order_id, amount paid, payment_method, bank_name_id (if applicable for bank transactions), transaction_id (if applicable), the received_by_user_id (current logged-in user), and optional notes.
FR9.2: The system shall support both full payments (where amount_paid equals total_amount of the order) and partial payments (where amount_paid is less than total_amount).
FR9.3: The RecordPaymentAndUpdateSalesOrder database procedure automatically updates the SalesOrders.amount_paid field by adding the new payment amount and associates the payment with the current active shift_id (obtained within the procedure via get_current_app_shift_id()).
FR9.4: Supported payment methods shall include at least: 'Cash' and 'Bank Transaction'. The list of payment methods should be easily extensible if needed in the future (though currently hardcoded in CHECK constraint).
FR9.5: For payments made via 'Bank Transaction', the user must select a BankName from the pre-defined list (managed by Admin users as per FR0.5) and enter the relevant bank transaction_id or reference number. These fields are mandatory for 'Bank Transaction' type payments.
FR9.6: Each Payment record must be irrevocably associated with the shift_id of the user's currently active shift at the time of recording the payment. This linkage is primarily enforced by the check_active_shift_for_transaction database trigger (which assigns NEW.shift_id based on get_current_app_shift_id()) and also within the RecordPaymentAndUpdateSalesOrder procedure.
FR10: Expense Management (Linked to Active Shift for Cash Expenses)
FR10.1: Authorized users shall be able to record general business Expenses. Each expense record shall include: expense_date, a selected expense_category_id (from the list managed by Admin), a detailed description of the expense, amount of the expense, and payment_method. The system will also automatically create expense entries for "Loss on Abandoned Orders" as detailed in FR8.10.
FR10.2: Admin users shall be responsible for managing the list of ExpenseCategories (CRUD operations, with names in English and Arabic), ensuring that a category such as "Loss on Abandoned Orders" exists or can be created to correctly categorize losses from uncollected goods.
FR10.3: For Expenses paid via 'Bank Transaction', users shall select a BankName from the pre-defined list and enter a transaction_id_ref (bank transaction reference).
FR10.4: Expenses that are paid using the 'Cash' payment_method (implying cash taken from the till) must be associated with the shift_id of the user's currently active shift at the time of recording. This linkage is enforced by the check_active_shift_for_transaction database trigger. Expenses paid by other methods (e.g., a bank transfer initiated outside the POS system's direct cash flow) may not require a shift link, or this can be an optional field for non-cash expenses.
FR11: Appointment Management
FR11.1: Authorized users shall be able to schedule Appointments for patients. Appointments will primarily be for order delivery/pickup or follow-up consultations and must be linked to a specific SalesOrder.
FR11.2: Each appointment record shall include: the associated sales_order_id, the scheduled appointment_datetime (date and time), an appointment_status (from a predefined list: 'Scheduled', 'Confirmed', 'Completed' (patient attended), 'Cancelled' (by center or patient), 'No Show' (patient did not attend without prior cancellation), 'Rescheduled'), and optional notes regarding the appointment.
FR11.3: The system should provide a user-friendly interface (e.g., a list view, potentially a simple daily/weekly calendar representation) to display and manage upcoming and past appointments. This interface should allow filtering by status, date range, and potentially by patient. Users should be able to easily update the status of an appointment.
FR12: Reporting
FR12.1: The system shall provide authorized users (with access controlled by permissions) with a suite of reports, which must be filterable by relevant criteria such as date ranges and, where applicable, by user (for shift reports viewed by Admins). These reports will leverage database views and functions for efficient and accurate data retrieval:
Sales Report: Provides detailed itemized sales information (products/services sold, quantities, prices, subtotals, discounts, patient details if applicable) and summary sales figures (e.g., total sales, sales by product category, sales by patient). This will primarily use the SalesDetailedView.
Profit and Loss Statement: Generated using the GenerateProfitAndLossStatement(start_date, end_date) database function. This statement must accurately calculate:
Revenue: Based on actual cash received (sum of Payments.amount for sales orders that are either 'Completed' or 'Abandoned' within the specified period).
Cost of Goods Sold (COGS): Based on the cost_price of InventoryItems included in 'Completed' sales orders only, within the specified period.
Gross Profit: Revenue - COGS.
Operating Expenses: Sum of all recorded Expenses within the period, including any "Loss on Abandoned Orders".
Net Profit/Loss: Gross Profit - Total Operating Expenses.
Expense Report: A detailed list of all recorded expenses, groupable and filterable by ExpenseCategory and period.
Inventory Valuation Report: Shows the current quantity_on_hand multiplied by their current cost_price for each active InventoryItem, providing a total inventory value at cost. This will primarily use the InventorySummaryView.
Low Stock Report: Lists all active InventoryItems where the quantity_on_hand is currently at or below their defined min_stock_level, to aid in reordering. This will use the LowStockItemsView.
Outstanding Payments Report: Lists all SalesOrders that have a balance_due greater than zero and are not in 'Cancelled' or 'Abandoned' status, including patient contact details. This will use the OutstandingPaymentsView.
Patient Purchase History Report: For a selected patient, this report will list all their past sales orders, including dates, items purchased, amounts, and payment status.
Shift Reports: As defined in FR3.6 (Summary and Detailed Transaction List for each shift), using ShiftReportSummaryView and ShiftReportDetailedTransactionsView.
FR12.2: All generated reports should be viewable on screen in a clear, well-formatted, and readable layout. They must also be printable (formatted appropriately for standard paper sizes like A4/Letter) and exportable to common data formats, primarily CSV (Comma Separated Values) for data analysis, and ideally to PDF for a universally viewable/shareable format.
FR12.3: The underlying logic for complex report data aggregation and calculation should preferably reside in database stored procedures, functions, or views (as demonstrated with GenerateProfitAndLossStatement and the various reporting views) to optimize performance, ensure data consistency, and simplify maintenance.
FR13: Audit Logging
FR13.1: The system shall automatically log changes (INSERT, UPDATE, DELETE operations) to critical data tables into the AuditLog table. Tables to be audited must include at least: CenterProfile, Users, UserPermissions, Shifts, Patients, Products, InventoryItems (especially changes to quantity_on_hand, cost_price, selling_price), PurchaseOrders, SalesOrders (especially status changes and financial totals), Payments, and Expenses.
FR13.2: Each audit log entry in the AuditLog table shall record: the table_name of the modified table, the record_pk (primary key value(s) of the affected record, stored as text), old_value (for UPDATEs and DELETEs, preferably as a JSON string representing the state of the record before the change, excluding non-critical columns like updated_at), new_value (for INSERTs and UPDATEs, preferably as a JSON string representing the state of the record after the change, excluding non-critical columns), the action_type ('INSERT', 'UPDATE', 'DELETE'), an action_timestamp (when the change occurred), and the user_id of the user who performed the action (retrieved via the get_current_app_user_id() database function, which relies on the app.current_user_id session variable being set by the application). An optional details field can store context-specific information (e.g., "Reason for stock adjustment: Damaged").
FR13.3: Audit logging will be primarily implemented using database triggers (e.g., the generic audit_changes_trigger_function or table-specific audit triggers applied to the relevant tables). These triggers will capture the necessary information upon data modification.
FR13.4: Admin users shall have exclusive access to a dedicated interface within the application to view the AuditLog entries. This interface must provide robust filtering capabilities, allowing Admins to filter the logs by criteria such as table name, user, date range, action type, and specific record primary key, to facilitate investigation, review, and compliance checks.
FR14: User Manual / Help Section
FR14.1: The system shall provide a "Help" or "User Manual" section, easily accessible from a main application menu item (e.g., a top-level "Help" menu with an option like "View User Manual" or "Contents").
FR14.2: The Help section shall contain comprehensive, user-friendly documentation written in clear and simple language (available in both English and Arabic, corresponding to the selected UI language). This documentation should explain how to use all major features, workflows (e.g., starting/ending a shift, processing a sale, managing inventory), and functionalities of the "Basariat POS" system. It should be well-structured, searchable if possible, and may include screenshots or diagrams where appropriate to aid understanding. The documentation will be bundled with the application for local access (e.g., as a set of interlinked HTML files displayable in JavaFX's WebView or a single PDF document opened by the system's default PDF viewer).
FR15: About Application Section
FR15.1: The system shall provide an "About Basariat POS" section, accessible from a main application menu item (e.g., "Help > About Basariat POS").
FR15.2: The "About Basariat POS" dialog or screen shall display the following information clearly and professionally:
Application Name: Basariat POS
Version Number: (e.g., v1.0.0 - this should be easily updatable with new releases, ideally read from a build properties file or an ApplicationSettings entry).
Brief Application Description: A concise summary of the application's purpose and primary function for optical centers.
Developer Credits:
Developed by (Arabic): أحمد محمد حمدناالله عبدالحافظ
Developed by (English): Ahmed Mohammed Hamednalla Abdelhafiz
Email: ahmed.abdelafiz97@gmail.com
Phone Numbers: +249 969 277 698, +249 112 139 452
Copyright Notice: e.g., © 2025 Ahmed Mohammed Hamednalla Abdelhafiz. All rights reserved. (The year should ideally be dynamic, reflecting the current year, or updated with new releases).
FR16: WhatsApp Click-to-Chat Notifications
FR16.1: The system shall provide a "Click-to-Chat" mechanism to allow authorized staff members to initiate WhatsApp messages to patients who have explicitly provided consent (i.e., Patients.whatsapp_opt_in = TRUE). This feature is intended to be free to use for the optical center as it relies on the user's existing WhatsApp installation (Desktop or Web) and requires manual sending of the message by the staff member.
FR16.2: Specific UI elements (e.g., "Notify via WhatsApp" buttons, icons, or context menu options) shall be available at relevant points in the application to trigger these notifications. Potential trigger points include, but are not limited to:
Patient Record screen (for sending a general message or follow-up).
Appointment schedule or details screen (for sending appointment confirmations or reminders).
Sales Order view screen (e.g., when an order status changes to 'Ready for Pickup', or for other order-related updates).
FR16.3: When a "Notify via WhatsApp" action is triggered by a staff member for a consenting patient:
The system shall retrieve the patient's primary phone number (stored in Patients.phone_number, which should include the international country code, e.g., 249 for Sudan).
The system shall generate a standard WhatsApp https://wa.me/ link. This link will be formatted as https://wa.me/<full_phone_number_international_format>?text=<url_encoded_pre_filled_message>.
The pre-filled message shall be constructed from a context-appropriate message template. These templates must utilize placeholders for dynamic data insertion (e.g., [PatientName], [DateTime], [OrderID], [CenterName], [BalanceDue]).
The system may optionally present a modal dialog showing the fully constructed pre-filled message, allowing the staff member to review or make minor edits to the message text before proceeding to open WhatsApp.
The system shall then attempt to open this generated wa.me/ link using the operating system's default web browser (e.g., via java.awt.Desktop.browse() or equivalent JavaFX mechanism such as HostServices.showDocument()).
FR16.4: The staff member will be solely responsible for manually reviewing the pre-filled message within their WhatsApp application (which will be launched by the browser) and then pressing the "Send" button within WhatsApp to dispatch the message. "Basariat POS" will not, and cannot, send the message automatically using this Click-to-Chat method.
FR16.5: "Basariat POS" will not track the sending status (e.g., "Sent," "Delivered," "Read") or receive replies for WhatsApp messages initiated via this "Click-to-Chat" method, as it operates outside the WhatsApp API.
FR16.6: Default message templates (in both English and Arabic) should be provided for common notification types (e.g., appointment reminder, order ready for pickup, payment due reminder). These templates should ideally be configurable by an Admin user through the application UI (e.g., via the ApplicationSettings table or a dedicated template management interface), allowing centers to customize the wording.
FR16.7: The "Notify via WhatsApp" UI elements (buttons/icons) should ideally be disabled or visually indicate (e.g., greyed out) if a patient has not consented to WhatsApp notifications (i.e., Patients.whatsapp_opt_in is FALSE or NULL). The action should be prevented if consent is not granted.
4. Non-Functional Requirements (NFR)
NFR1: Performance:
NFR1.1: UI Responsiveness: Common interactive operations such as opening forms, saving data, performing simple searches, and navigating between screens should complete within 2-3 seconds under typical load conditions (e.g., database with records for a year of operation for a small to medium center).
NFR1.2: Report Generation: Generation of standard monthly reports (e.g., Sales, P&L, Inventory Valuation, Shift Summary) for a typical small to medium-sized optical center's dataset should complete within 30 seconds. More complex reports or those spanning very large date ranges (e.g., annual P&L) should show progress indication if they are expected to take longer and should not freeze the UI.
NFR1.3: Concurrent Users: The system, when deployed with the client application connecting to a local PostgreSQL server on a LAN, should comfortably support 1-5 concurrent users (e.g., multiple cashier stations and an admin station performing typical daily tasks) without significant performance degradation in UI responsiveness or transaction processing times.
NFR1.4: Shift Operations: Starting, pausing, resuming, and ending shifts, including the cash reconciliation calculations performed by the EndShift procedure, should be performed efficiently, typically completing within a few seconds to not impede user workflow.
NFR1.5: Database Query Performance: Database queries, especially those backing frequently used UI views and reports, must be optimized (e.g., through proper indexing as defined in the DB schema, efficient query writing) to ensure fast data retrieval.
NFR2: Usability:
NFR2.1: Ease of Use & Learnability: The system must be highly intuitive, user-friendly, and easy to learn, particularly for users in the 'Cashier' role who may have limited technical expertise. The design should minimize cognitive load. Minimal training (e.g., a few hours with the User Manual) should be required for users to perform common daily tasks efficiently and accurately.
NFR2.2: UI Design & Consistency: The user interface, built with JavaFX, should be clean, uncluttered, and visually appealing, adhering to the defined theme (inspired by IMG_20250515_110759.jpg, with beige/cream backgrounds, deep brown/maroon text, and purple/mauve accents, using rounded corners and clear iconography). The UI design, including component placement, terminology, interaction patterns, and visual styling, must be consistent across all modules and screens of the application to promote familiarity and reduce user confusion.
NFR2.3: Feedback & Error Handling: The system must provide clear, concise, and immediate feedback to users for their actions (e.g., "Data saved successfully," "Shift started," "WhatsApp link opened"). Error messages must be informative, non-technical, written in plain language (in the selected UI language), and should, where possible, provide constructive guidance on how to resolve the issue or what to try next. Errors should be handled gracefully without crashing the application.
NFR2.4: Help Documentation Accessibility: The User Manual/Help section must be easily accessible from within the application (e.g., via a main "Help" menu) and provide clear, step-by-step instructions, potentially with screenshots, for using all features.
NFR2.5: Efficiency: Workflows for common tasks (e.g., processing a sale, starting/ending a shift, searching for a patient) should be optimized to require the minimum number of steps and clicks. Keyboard navigation and shortcuts for frequent actions should be supported.
NFR3: Reliability:
NFR3.1: System Stability: The application should be stable and robust, operating without frequent crashes, freezes, or unexpected behavior during normal usage patterns and anticipated data volumes.
NFR3.2: Data Integrity & Consistency: Data integrity must be strictly maintained at all times. This will be achieved through:
Comprehensive database-level constraints (Primary Keys, Foreign Keys with appropriate ON DELETE/ON UPDATE actions, CHECK constraints, NOT NULL constraints, UNIQUE constraints).
Atomic database transactions for all operations that involve multiple related data modifications (e.g., processing a sale and updating inventory, ending a shift and calculating totals) to ensure that either all changes are committed or none are.
Thorough input validation at both the UI layer (for immediate user feedback) and within the business logic/data access layer (as a secondary check for security and integrity).
NFR3.3: Backup & Recovery Responsibility: While the "Basariat POS" application itself will not perform automated database backups, the system documentation (specifically the User Manual section for Administrators) must strongly recommend and provide clear, actionable guidance on the critical importance of establishing a robust, regular (e.g., daily automated) backup and recovery strategy for the PostgreSQL database. This responsibility for implementing and verifying backups lies with the optical center owner or their designated IT administrator.
NFR3.4: Interruption Handling: The system should gracefully handle unexpected interruptions, such as an application client closing unexpectedly during an active shift, by allowing the user to resume their work or appropriately finalize the interrupted state upon next login (as defined in FR3.5). Data involved in an incomplete transaction that was interrupted should not be left in an inconsistent state in the database.
NFR4: Security:
NFR4.1: Password Management: User passwords must be securely hashed using a strong, modern, and salted hashing algorithm (e.g., bcrypt or Argon2) before being stored in the Users.password_hash field. Plaintext passwords must never be stored or logged by the system at any point. The system should enforce minimum password complexity rules if configurable by an Admin (e.g., length, character types).
NFR4.2: Access Control: Comprehensive role-based access control (RBAC) using 'Admin' and 'Cashier' roles, supplemented by granular permission checks (via UserPermissions table), must be rigorously enforced for all system functionalities, data views, and data modification operations. Users must only be able to perform actions and access data for which they have explicit authorization.
NFR4.3: Input Validation & Injection Prevention: All user-supplied inputs must be thoroughly validated on both the client-side (JavaFX UI, for immediate user feedback) and, more importantly, on the server-side/business-logic-layer (before database interaction) to prevent common application vulnerabilities, including SQL injection. The use of jOOQ as a type-safe SQL builder significantly mitigates direct SQL injection risks, but parameter validation is still crucial.
NFR4.4: Audit Log Protection: The AuditLog table and its data should be protected from unauthorized modification or deletion by regular application users. Database permissions should restrict direct DML (Data Manipulation Language) access to this table for the application's standard database user role; only specific, trusted database processes (like the audit triggers themselves) or a database superuser should have write/delete access.
NFR4.5: Session Management & Context: User sessions should be managed securely. The application must ensure that the current user context (app.current_user_id) and active shift context (app.current_shift_id) are correctly and securely set in the PostgreSQL database session upon user login/shift start and are reliably cleared or invalidated upon user logout/shift end or session termination. These context variables are critical for audit logging and transaction linkage.
NFR4.6: Data Exposure: Sensitive data (e.g., financial summaries, patient details) should only be displayed to users with the appropriate permissions. Reports and UI views should be designed to respect these access controls.
NFR5: Maintainability:
NFR5.1: Code Quality & Structure: The Java source code must be well-structured, following principles of modular design (e.g., clear separation of UI/JavaFX views and controllers, business logic/services, data access/repositories, and domain model) as outlined in the System Architecture document. Code must adhere to established Java coding best practices and conventions (e.g., naming conventions, proper use of OOP). It must include comprehensive Javadoc comments for public APIs (classes and methods) and inline comments for complex or non-obvious logic sections.
NFR5.2: Database Interaction (jOOQ): The use of jOOQ should be consistent and leverage its features for type-safe SQL, query building, and record mapping to ensure maintainable and less error-prone database interaction code. jOOQ generated code should be kept up-to-date with any schema changes.
NFR5.3: Internationalization (i18n): All UI display strings must be externalized into Java Resource Bundles (.properties files for English and Arabic). This design facilitates easy translation, modification of existing text, and the potential addition of new languages in the future without code changes.
NFR5.4: Database Schema Documentation & Evolution: The PostgreSQL database schema, including all tables, columns, data types, constraints, views, functions, stored procedures, and triggers, must be well-documented within the master SQL script itself (using comments) and referenced/summarized in this SRS. Any future schema changes must be managed through versioned migration scripts.
NFR5.5: Configuration Management: Application configuration parameters (e.g., database connection details, default paths, version number) should be managed through external configuration files (e.g., .properties files loaded at startup) or the ApplicationSettings database table, rather than being hardcoded into the application.
NFR5.6: Testability: The application code should be designed with testability in mind. This includes writing modular components with clear interfaces, using dependency injection where appropriate to facilitate unit testing with mocking frameworks (e.g., Mockito), and developing a comprehensive suite of automated unit and integration tests (e.g., using JUnit 5).
NFR5.7: Build Process: The build process (Maven or Gradle) should be automated, reliable, and capable of producing consistent deployment packages. It should also be able to run all automated tests as part of the build.
NFR6: Internationalization (i18n) / Localization (l10n):
NFR6.1: UI Text & Resource Bundles: All static text displayed in the User Interface (including labels on forms, button text, menu items, informational messages, dialog titles, tooltips, and fixed content in the "About Basariat POS" section) must be externalized using Java Resource Bundles. Separate .properties files for English (messages_en.properties) and Arabic (messages_ar.properties), both UTF-8 encoded, are required.
NFR6.2: Default Language & Language Switching: Arabic (ar) shall be the default UI language for the application upon first launch or if no user preference is detected. Users must be provided with an easily accessible and intuitive mechanism (e.g., a dropdown menu in a global application header/footer or within a dedicated settings panel) to switch the UI language to English (en) and back to Arabic. The selected language preference should ideally be persisted per user (e.g., in a user profile setting) or, if not per user, at least per system installation, so it is remembered across application sessions.
NFR6.3: Layout Direction (RTL/LTR): The UI, built with JavaFX, must dynamically adapt its layout and component orientation to fully support Right-to-Left (RTL) for the Arabic language and Left-to-Right (LTR) for the English language. This adaptation includes, but is not limited to, text alignment within components, placement of labels relative to their associated input fields (e.g., labels to the right of fields in RTL), mirroring of icons that have inherent directional meaning (e.g., back/forward navigation arrows, sort indicators in TableView headers), and the overall flow of UI elements within containers and navigation structures.
NFR6.4: Data Storage & Encoding: The PostgreSQL database must be configured to use UTF-8 encoding to ensure correct storage and retrieval of multilingual data, including Arabic characters in patient names, product names and descriptions, CenterProfile details, etc., without data corruption or display issues like Mojibake. The Java application must also consistently use UTF-8 for all string processing, file I/O, and database interactions.
NFR6.5: Date, Number, and Currency Formatting: The display of dates, numbers, and currency values within the UI and on reports should be formatted in a way that is clear, unambiguous, and culturally appropriate for the user, considering the application's current UI language setting.
Dates: Use Java's java.time.format.DateTimeFormatter class with appropriate Locale objects (e.g., new Locale("ar", "SD") for Sudanese Arabic to get specific regional date formats if they differ from generic Arabic, or Locale.ENGLISH / Locale.US / Locale.UK for English variants) to format dates for display. For storage in the database, standard ISO date/timestamp formats (YYYY-MM-DD HH:MM:SS) should be used.
Numbers: Use java.text.NumberFormat.getNumberInstance(currentLocale) for displaying general numbers if locale-specific formatting for decimal separators (e.g., comma versus period) or grouping separators (for thousands) is required and differs between Arabic and English conventions.
Currency: The currency symbol (e.g., "SDG", "$", "€") and code (e.g., "SDG", "USD", "EUR") displayed will be sourced from the CenterProfile.currency_symbol and CenterProfile.currency_code settings. Numerical currency values should be formatted using NumberFormat.getCurrencyInstance() configured with a Locale that is appropriate for the currency (if possible, though this can be complex for all world currencies), or more reliably, by using a standard DecimalFormat to ensure a fixed number of decimal places (e.g., 2 for most currencies). The configured currency_symbol from CenterProfile should then be appropriately prefixed or suffixed to the formatted number according to common conventions for that currency or the selected locale. Consistency in display is key.
NFR6.6: Help Documentation Language: The content of the User Manual/Help section should be prepared and made available in both English and Arabic, corresponding to the application's supported UI languages. The application should display the help content in the currently selected UI language.
NFR7: Configurability:
NFR7.1: Center-Specific Setup & Management: The system must allow an Admin user at each optical center to easily configure their unique business details (as defined in the CenterProfile table, e.g., center name, address, contact information, logo image path, currency settings, default receipt footer message) through the application UI. This includes an initial setup wizard for new installations and an ongoing settings management interface for later modifications, all without requiring any code changes or direct database manipulation by the end-user.
NFR7.2: Operational Data Management: Key operational lookup data lists, such as BankNames, ExpenseCategories, and ProductCategories, must be fully manageable (Create, Read, Update, Deactivate/Reactivate) by Admin users through dedicated interfaces within the application UI.
NFR7.3: WhatsApp Message Templates Configuration: Default templates for the pre-filled messages used in the WhatsApp "Click-to-Chat" feature (for various contexts like appointment reminders, order ready notifications) should be configurable by an Admin user, allowing centers to customize the wording. These templates could be stored in the ApplicationSettings table or a dedicated new table and managed via a UI.
5. Interface Requirements
5.1 User Interface (UI):
A Graphical User Interface (GUI) shall be developed using JavaFX (compatible with Java 21) and is intended for desktop application use.
The UI must implement the visual theme as specified in the "UI/UX Considerations" document, leveraging JavaFX's CSS capabilities for styling to achieve the desired aesthetic (beige/cream backgrounds, deep brown/maroon text, purple/mauve accents, rounded corners, etc.).
The UI must fully support dynamic switching and rendering for Right-to-Left (RTL - Arabic) and Left-to-Right (LTR - English) layouts and text direction. FXML is recommended for defining UI layouts to separate presentation from Java controller logic.
It must provide intuitive and efficient access to all functionalities outlined in the Functional Requirements, strictly respecting the logged-in user's roles and permissions (e.g., disabling or hiding controls for unauthorized actions).
Standard JavaFX UI controls (e.g., Button, TextField, TableView, ComboBox, DatePicker, CheckBox, RadioButton, Menu, Dialog, Stage, Scene) should be used consistently and appropriately. Custom controls may be developed if standard controls are insufficient.
5.2 Hardware Interfaces:
Input Devices: The system will interact with standard PC input devices: a QWERTY (and Arabic-enabled) Keyboard and a Mouse (or other pointing device).
Display: The application should be designed to be optimally usable on displays with a minimum screen resolution of 1024x768 pixels. It should gracefully handle common modern display resolutions (e.g., 1366x768, 1920x1080) and aspect ratios.
Printer: Compatibility with standard operating system-recognized printers for generating hard copies of:
Receipts (for sales and payments - potentially on smaller thermal receipt printers if common, though initial support will target standard page sizes).
Invoices/Sales Orders.
Reports (Shift reports, financial reports, inventory reports, etc. - formatted for standard A4 or Letter paper sizes).
Network Interface Card (NIC): Required on all client machines and the database server machine for LAN connectivity to the PostgreSQL database server.
5.3 Software Interfaces:
Operating System (Client & Server):
Client: Primarily Windows Desktop versions (e.g., Windows 10, Windows 11). Due to JavaFX's cross-platform capabilities, it should be potentially runnable on Linux Desktop (e.g., Ubuntu, Fedora) and macOS with the appropriate JRE (including JavaFX modules), but primary development focus, testing, and official support will target Windows environments.
Server (for PostgreSQL): Can be Windows Desktop/Server, Linux Server.
Java Runtime Environment (JRE) / Java Development Kit (JDK): JRE version 21 (or the specific compatible LTS version used for development), including all necessary JavaFX modules, must be installed on all machines running the "Basariat POS" client application. Consideration should be given to bundling a custom JRE with JavaFX modules using jlink for easier deployment.
Database Management System (DBMS): PostgreSQL (specific version, e.g., 14, 15, or 16), accessed via a JDBC Type 4 driver (e.g., PostgreSQL JDBC Driver).
Data Access Framework: jOOQ library, compatible with the chosen Java and PostgreSQL versions.
Web Browser (for WhatsApp Click-to-Chat): The system will rely on the user's default operating system web browser (e.g., Chrome, Firefox, Edge) to open https://wa.me/ links for the WhatsApp "Click-to-Chat" feature. The application will use java.awt.Desktop.browse() or an equivalent JavaFX mechanism (e.g., HostServices.showDocument()) for this.
(Optional) PDF Generation Library: If direct PDF export for reports is implemented within the application (beyond OS print-to-PDF capabilities), a library such as Apache PDFBox (open source) or iText (commercial licenses for some uses, community version available) might be used.
(Optional) CSV Handling Library: For robust CSV export functionality for reports, a library like Apache Commons CSV or OpenCSV could be utilized.
Application Packaging Tool (Consideration): The jpackage tool (part of the JDK since Java 14) should be considered for creating native application bundles (e.g., .exe for Windows with an installer, .dmg for macOS, .deb/.rpm for Linux) that can include the JRE and JavaFX modules, simplifying distribution and installation for end-users and ensuring all dependencies are met.
