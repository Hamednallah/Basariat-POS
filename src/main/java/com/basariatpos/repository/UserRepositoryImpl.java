package com.basariatpos.repository;

import com.basariatpos.config.DBManager;
import com.basariatpos.db.generated.tables.records.UserpermissionsRecord;
import com.basariatpos.db.generated.tables.records.UsersRecord;
import com.basariatpos.model.UserDTO;
import com.basariatpos.util.AppLogger;

import org.jooq.DSLContext;
import org.jooq.exception.DataAccessException;
import org.slf4j.Logger;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.basariatpos.db.generated.Tables.USERS;
import static com.basariatpos.db.generated.Tables.USERPERMISSIONS;

public class UserRepositoryImpl implements UserRepository {

    private static final Logger logger = AppLogger.getLogger(UserRepositoryImpl.class);

    @Override
    public Optional<UserDTO> findByUsername(String username) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            UsersRecord record = dsl.selectFrom(USERS)
                                    .where(USERS.USERNAME.eq(username))
                                    .fetchOne();
            return Optional.ofNullable(record).map(this::mapUserRecordToDtoWithPermissions);
        } catch (DataAccessException e) {
            logger.error("Error finding user by username '{}': {}", username, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public Optional<UserDTO> findById(int userId) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            UsersRecord record = dsl.selectFrom(USERS)
                                    .where(USERS.USER_ID.eq(userId))
                                    .fetchOne();
            return Optional.ofNullable(record).map(this::mapUserRecordToDtoWithPermissions);
        } catch (DataAccessException e) {
            logger.error("Error finding user by ID {}: {}", userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public UserDTO save(UserDTO userDto, String passwordHash) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            UsersRecord record = dsl.newRecord(USERS);
            mapUserDtoToRecord(userDto, record); // Maps basic fields like username, full_name, role, is_active
            record.setPasswordHash(passwordHash);
            // Assuming user_id is auto-generated by the database (SERIAL type)
            // If not, it needs to be set explicitly or via a sequence.
            record.store(); // Inserts the record
            userDto.setUserId(record.getUserId()); // Update DTO with generated ID
            logger.info("User '{}' saved with ID {}.", userDto.getUsername(), userDto.getUserId());
            // Permissions are typically granted separately after user creation
            return userDto;
        } catch (DataAccessException e) {
            logger.error("Error saving user '{}': {}", userDto.getUsername(), e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public UserDTO update(UserDTO userDto) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            UsersRecord record = dsl.fetchOne(USERS, USERS.USER_ID.eq(userDto.getUserId()));
            if (record == null) {
                throw new DataAccessException("User with ID " + userDto.getUserId() + " not found for update.");
            }
            // Only update specific fields, not password hash or username typically
            record.setFullName(userDto.getFullName());
            record.setRole(userDto.getRole());
            record.setIsActive(userDto.isActive());
            record.store(); // Updates the record
            logger.info("User ID {} updated.", userDto.getUserId());
            return userDto; // Or re-fetch and return DTO from DB
        } catch (DataAccessException e) {
            logger.error("Error updating user ID {}: {}", userDto.getUserId(), e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public void updateUserPassword(int userId, String newPasswordHash) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            int updatedRows = dsl.update(USERS)
                                 .set(USERS.PASSWORD_HASH, newPasswordHash)
                                 .where(USERS.USER_ID.eq(userId))
                                 .execute();
            if (updatedRows == 0) {
                throw new DataAccessException("User with ID " + userId + " not found for password update.");
            }
            logger.info("Password updated for user ID {}.", userId);
        } catch (DataAccessException e) {
            logger.error("Error updating password for user ID {}: {}", userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public List<UserDTO> findAll() {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            return dsl.selectFrom(USERS)
                      .fetch()
                      .map(this::mapUserRecordToDtoWithPermissions); // Fetch permissions for each user
        } catch (DataAccessException e) {
            logger.error("Error finding all users: {}", e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public void setUserActiveStatus(int userId, boolean isActive) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            int updatedRows = dsl.update(USERS)
                                 .set(USERS.IS_ACTIVE, isActive)
                                 .where(USERS.USER_ID.eq(userId))
                                 .execute();
            if (updatedRows == 0) {
                throw new DataAccessException("User with ID " + userId + " not found for status update.");
            }
            logger.info("Active status for user ID {} set to {}.", userId, isActive);
        } catch (DataAccessException e) {
            logger.error("Error setting active status for user ID {}: {}", userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public void grantPermission(int userId, String permissionName) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            UserpermissionsRecord record = dsl.fetchOne(USERPERMISSIONS,
                                                       USERPERMISSIONS.USER_ID.eq(userId)
                                                       .and(USERPERMISSIONS.PERMISSION_NAME.eq(permissionName)));
            if (record == null) {
                dsl.insertInto(USERPERMISSIONS, USERPERMISSIONS.USER_ID, USERPERMISSIONS.PERMISSION_NAME, USERPERMISSIONS.IS_GRANTED)
                   .values(userId, permissionName, true)
                   .execute();
                logger.info("Permission '{}' granted to user ID {}.", permissionName, userId);
            } else {
                if (!record.getIsGranted()) {
                    record.setIsGranted(true);
                    record.store();
                    logger.info("Permission '{}' re-granted to user ID {}.", permissionName, userId);
                } else {
                     logger.info("Permission '{}' was already granted to user ID {}. No change.", permissionName, userId);
                }
            }
        } catch (DataAccessException e) {
            logger.error("Error granting permission '{}' to user ID {}: {}", permissionName, userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public void revokePermission(int userId, String permissionName) {
         DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            int updatedRows = dsl.update(USERPERMISSIONS)
                                 .set(USERPERMISSIONS.IS_GRANTED, false)
                                 .where(USERPERMISSIONS.USER_ID.eq(userId)
                                        .and(USERPERMISSIONS.PERMISSION_NAME.eq(permissionName)))
                                 .execute();
            if (updatedRows > 0) {
                 logger.info("Permission '{}' revoked for user ID {}.", permissionName, userId);
            } else {
                 logger.warn("Permission '{}' not found or already revoked for user ID {}. No change.", permissionName, userId);
            }
        } catch (DataAccessException e) {
            logger.error("Error revoking permission '{}' for user ID {}: {}", permissionName, userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public List<String> findUserPermissions(int userId) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            return dsl.select(USERPERMISSIONS.PERMISSION_NAME)
                      .from(USERPERMISSIONS)
                      .where(USERPERMISSIONS.USER_ID.eq(userId).and(USERPERMISSIONS.IS_GRANTED.isTrue()))
                      .fetch(USERPERMISSIONS.PERMISSION_NAME);
        } catch (DataAccessException e) {
            logger.error("Error finding permissions for user ID {}: {}", userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    @Override
    public boolean hasPermission(int userId, String permissionName) {
        DSLContext dsl = null;
        try {
            dsl = DBManager.getDSLContext();
            if (dsl == null) throw new DataAccessException("DSLContext not available");

            return dsl.fetchExists(
                dsl.selectOne()
                   .from(USERPERMISSIONS)
                   .where(USERPERMISSIONS.USER_ID.eq(userId)
                          .and(USERPERMISSIONS.PERMISSION_NAME.eq(permissionName))
                          .and(USERPERMISSIONS.IS_GRANTED.isTrue()))
            );
        } catch (DataAccessException e) {
            logger.error("Error checking permission '{}' for user ID {}: {}", permissionName, userId, e.getMessage(), e);
            throw e;
        } finally {
            closeContext(dsl);
        }
    }

    // Helper Methods
    private UserDTO mapUserRecordToDto(UsersRecord record) {
        if (record == null) return null;
        return new UserDTO(
                record.getUserId(),
                record.getUsername(),
                record.getFullName(),
                record.getRole(),
                record.getIsActive(),
                null, // Permissions list loaded separately if needed by mapUserRecordToDtoWithPermissions
                record.getPasswordHash()
        );
    }

    private UserDTO mapUserRecordToDtoWithPermissions(UsersRecord record) {
        if (record == null) return null;
        UserDTO dto = mapUserRecordToDto(record);
        if (dto != null) {
            dto.setPermissions(findUserPermissions(record.getUserId())); // Fetch and set permissions
        }
        return dto;
    }


    private void mapUserDtoToRecord(UserDTO dto, UsersRecord record) {
        // user_id is typically not mapped here as it's an identity or set separately for new records.
        record.setUsername(dto.getUsername());
        record.setFullName(dto.getFullName());
        record.setRole(dto.getRole());
        record.setIsActive(dto.isActive());
        // password_hash is set separately in the save method.
    }

    private void closeContext(DSLContext dslContext) {
        if (dslContext != null) {
            try {
                dslContext.close();
            } catch (Exception e) {
                logger.warn("Failed to close DSLContext.", e);
            }
        }
    }
}
