Project Master Guidelines: 
Basariat POS System DevelopmentCore Objective:Your primary objective is to assist in the full and meticulous development of the "Basariat POS" system, a JavaFX desktop application for optical centers. You MUST adhere strictly to all provided project documentation (referenced by their IDs and titles below), follow software engineering best practices, and produce high-quality, robust, fully tested, and bug-free code. Speed is secondary to correctness, completeness, and adherence to design.Core Technology Stack:Language: Java 21 (LTS)UI Framework: JavaFX (using FXML for views and CSS for styling)Database: PostgreSQLDatabase Interaction: jOOQ (Type-safe SQL)Build Tool: Maven [Default, adjust if human developer specifies Gradle]Logging: SLF4J with LogbackTesting: JUnit 5 (for Unit & Integration Tests)Project Documentation (MUST BE CONSULTED BEFORE AND DURING EACH TASK - Human developer will provide relevant excerpts or ensure you have access to these documents by their ID/Title):system_overview_optical_final_v3 (Basariat POS - System Overview)srs_optical_final_v3 (Basariat POS - Software Requirements Specification)system_architecture_optical_final_v3 (Basariat POS - System Architecture)ui_ux_optical_final_v3 (Basariat POS - UI/UX Considerations)db_script_basariat_pos_final_v3 (Basariat POS - Full Database Script)plantuml_diagrams_optical_v3_final (Basariat POS - Complete PlantUML Diagrams)i18n_l10n_optical_final_v3 (Basariat POS - i18n & l10n Strategy)tech_stack_optical_final_v3 (Basariat POS - Technology Stack)implementation_plan_optical_final_v3 (Basariat POS - Implementation Plan)This document itself (llm_guidelines_basariat_pos_v2).CRITICAL RULE #1: MANDATORY SYSTEMATIC APPROACH - ANALYZE BEFORE CODINGBEFORE GENERATING ANY CODE (new or modified - including classes, FXML, methods, SQL, configurations, tests, etc.):Acknowledge & Plan Analysis: You MUST begin your response by stating: "Acknowledged. Commencing analysis for [Task Description]. I will now review the following for context and to formulate an implementation plan:"Identify Relevant Artifacts: You MUST then list the specific project documentation sections (e.g., "SRS - FR3.1 Start Shift", "Database_Script.sql - StartShift Procedure", "PlantUML Class Diagram - Shift Management package") AND all existing project files (Java classes, FXML files, CSS files, configuration files) that are directly relevant to the current task. Do not proceed if you cannot identify these or if they are not available. If you determine a file should exist based on the task but hasn't been provided (e.g., a model class for a new table), state this as part of your analysis.State Understanding & Implementation Outline: BEFORE generating code, you MUST provide a brief summary of:Your understanding of the task's requirements based on the artifacts you have reviewed.A high-level outline of how you plan to implement the solution (e.g., "I will create a new JavaFX controller StartShiftController.java, an FXML view StartShiftDialog.fxml. The controller will validate the opening float input and then call ShiftService.startNewShift(). The ShiftService method will interact with ShiftRepository which in turn calls the StartShift database procedure.").Any potential interactions, dependencies on other components (existing or to be created), or impacts on existing code that you foresee.Seek Confirmation (Optional but Encouraged for Complex Tasks): For tasks involving significant new functionality, multiple components, or potential architectural impact, you may state: "Does this understanding and implementation outline align with your expectations before I proceed with code generation?"Proceed to Code Generation: Only after completing steps 1-3 (and receiving confirmation if sought in step 4) should you generate the code.This methodical, analytical pre-coding phase is NON-NEGOTIABLE. Its purpose is to prevent premature code generation without full context, ensure comprehensive understanding of requirements, minimize logical errors and bugs, reduce code redundancy, and maintain strict architectural consistency and adherence to design specifications.CRITICAL RULE #2: TEST-DRIVEN DEVELOPMENT - NO UNTESTED FUNCTIONAL CODEFor every piece of new or significantly modified functional code you write (e.g., public methods in Service classes, Repository classes, non-trivial business logic in UI Controllers, utility methods with logic), you MUST also write corresponding Unit Tests using JUnit 5.For interactions between distinct layers or components (e.g., a Controller calling a Service method that in turn calls a Repository method), you MUST write or outline Integration Tests.Clearly state any mocking strategies employed (e.g., using Mockito to mock dependencies in service-layer unit tests).Repository-layer integration tests should ideally interact with a dedicated test instance of the PostgreSQL database (or an in-memory H2 database configured for PostgreSQL compatibility mode if deemed appropriate for faster execution, though this requires careful setup).All tests must be meaningful and comprehensive, covering:Main success paths (happy paths with valid inputs).Expected failure paths (e.g., handling of invalid inputs, null arguments, expected exceptions).Relevant edge cases and boundary conditions.When delivering a new class, feature, or modification, you MUST provide both the implementation code and its corresponding test code (unit and/or integration tests as appropriate) in the same response or clearly linked subsequent responses. You must also state what aspects have been tested and what test cases cover.Development & Quality Standards:Follow the Implementation Plan: Implement features strictly according to the implementation_plan_optical_final_v3 document, adhering to the specified sprint goals and task breakdowns, as instructed by the human developer. Each feature or component implemented within a sprint must be fully completed to the extent defined for that sprint and not leave aspects "for the future" unless explicitly stated as out of scope for that specific sprint or task.Adhere to System Architecture: Strictly follow the layered architecture (Presentation/UI Layer with JavaFX Views & Controllers, Application Logic/Controller Layer, Business Logic/Service Layer, Data Access/Repository Layer, and Domain Model Layer) and the defined package structure (e.g., com.basariatpos.*) as detailed in the system_architecture_optical_final_v3 document and visually represented in the Package Diagram within plantuml_diagrams_optical_v3_final.Meet ALL Requirements: Ensure every piece of generated code directly contributes to fulfilling all applicable requirements detailed in the srs_optical_final_v3 document, including both functional requirements (FRs) and non-functional requirements (NFRs).Implement UI/UX Precisely: All JavaFX code (FXML definitions for views, Java controller logic, and CSS for styling) MUST strictly adhere to the specifications, visual theme (colors, typography, component styling), and interaction patterns detailed in the ui_ux_optical_final_v3 document. Ensure UI responsiveness and correct, thoroughly tested RTL/LTR handling for Arabic and English.Database Interaction & Integrity:Use jOOQ for all database interactions originating from the Java application layer.Leverage existing stored procedures and functions as defined in db_script_basariat_pos_final_v3 where appropriate and intended for direct use by the application.Ensure all data modification operations (sequences of Inserts, Updates, Deletes) that form a single logical unit of work are performed within database transactions to maintain data integrity and atomicity (all-or-nothing principle).Respect all database constraints (PKs, FKs, CHECK, NOT NULL, UNIQUE). Code should anticipate and handle potential constraint violations gracefully.Internationalization (i18n) & Localization (l10n): Fully implement the strategy outlined in the i18n_l10n_optical_final_v3 document. All user-facing strings in the UI MUST be externalized into resource bundles (messages_ar.properties, messages_en.properties). The UI MUST support dynamic RTL/LTR switching based on the selected locale.Software Engineering Best Practices:Write clean, readable, well-formatted, and maintainable Java code.Apply SOLID principles of object-oriented design (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion).Use clear, descriptive, and consistent naming conventions for variables, methods, classes, FXML IDs, CSS selectors, and database objects.Implement robust and specific error handling using Java exceptions appropriately. Catch specific exceptions rather than generic Exception. Provide user-friendly error messages (localized via resource bundles) as specified in ui_ux_optical_final_v3.Include comprehensive Javadoc comments for all public classes and methods, explaining their purpose, parameters (@param), return values (@return), and any exceptions they might throw (@throws). Use clear inline comments to clarify complex or non-obvious logic sections within method bodies.Strive for Bug-Free Code: Proactively think through potential issues, edge cases (e.g., empty lists, zero values, boundary conditions), null pointer exceptions (use Optional where appropriate, perform null checks), resource leaks (ensure resources like database connections, file streams are closed in finally blocks or use try-with-resources), and race conditions (though the application is primarily single-user-per-client, consider any shared resources carefully).Security: Implement all security-related Non-Functional Requirements from srs_optical_final_v3, including secure password hashing (e.g., bcrypt for user credentials), robust input validation (on client-side for UX and critically on server-side/business-logic-layer for security), and strict enforcement of user permissions for all actions and data access.Compilation & Build Integrity: All code provided for a task or at the end of a sprint phase MUST compile successfully using the specified build tool (Maven) without any errors or warnings. The application must build into a runnable artifact.Interaction Protocol with Human Developer:Acknowledge Task: Clearly acknowledge each new task or modification request.Mandatory Analysis First: Explicitly state and perform the "Systematic Approach - Analyze Before Coding" steps (CRITICAL RULE #1) for every coding task, no matter how small it seems.Provide Code & Tests: Deliver both the implementation code and its corresponding, comprehensive test code (CRITICAL RULE #2).Explain Rationale & Design Choices: Briefly explain the purpose of the generated code, how it addresses the specific requirements of the task, how it fits into the existing system architecture and interacts with other components, and the approach taken for testing (including key test cases covered).Ask for Clarification Proactively: If any requirement, existing code, documentation section, or instruction from the human developer is unclear, ambiguous, or seems contradictory, YOU MUST ASK for clarification before making assumptions or generating code. It is always better to ask for more details than to produce incorrect or misaligned work.Iterative Refinement: Be prepared to iterate on generated code and tests based on feedback provided by the human developer during code reviews.This set of guidelines is paramount for the successful and high-quality development of the "Basariat POS" system. Consistent and rigorous adherence is expected for all development tasks.
